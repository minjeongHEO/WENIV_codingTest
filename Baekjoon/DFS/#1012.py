# 유기농 배추
# DFS
import sys
sys.setrecursionlimit(10**6) # sys.setrecursionlimit(10 ** 6)은 파이썬의 최대 재귀 깊이 제한을 늘리는 코드입니다.
'''
 파이썬은 기본적으로 재귀 함수 호출을 약 1000번까지만 허용합니다. 이는 무한 루프에 빠지는 것을 방지하기 위한 안전장치로 볼 수 있습니다. 
 그러나, 알고리즘 문제를 풀 때에는 이보다 더 깊은 재귀가 필요한 경우가 종종 있습니다.
 이럴 때 사용하는 것이 sys.setrecursionlimit() 함수입니다. 이 함수를 사용하여 파이썬의 최대 재귀 깊이 제한을 늘릴 수 있습니다. 
 10 ** 6은 1,000,000을 의미하므로, 이 코드는 재귀 함수 호출을 최대 1,000,000번까지 가능하게 설정하는 것입니다.
 그러나 재귀 깊이를 무리하게 늘리면 스택 오버플로우(stack overflow)와 같은 문제가 발생할 수 있으니, 이를 고려하여 적절한 재귀 깊이를 설정해야 합니다.
'''

input = sys.stdin.readline
MAX = 50+10

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(y, x):
    # 방문처리하고
    graph[y][x] = False

    # 상 하 좌 우 도 재귀호출
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        # if 0 <= nx < m and 0 <= ny < n and graph[nx][ny]:  # nx와 ny가 그래프의 범위 내에 있는지 확인
        # => 애초에 graph배열을 최댓값(50)+10 크기만큼 만들었기 떄문에 범위확인 생략이 가능
        # 배추밭의 가로길이 M(1 ≤ M ≤ 50:최댓값)과 세로길이 N(1 ≤ N ≤ 50:최댓값),
        if graph[ny][nx]:
            dfs(ny, nx)


#0. 입력 및 초기화
t = int(input()) #테스트 케이스의 개수
for _ in range(t):
    m, n, k = map(int, input().split())  # 밭가로길이(m). 밭세로길이(n), 배추심어진개수
    # 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주
    # graph = [[0]*(m+1) for _ in range(n+1)]
    # 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50),
    # graph = [[0] * (n + 1) for _ in range(m + 1)]  # 왜지?????????
    graph = [[False] * (MAX + 10) for _ in range(MAX + 10)]
    '''
    최초에 배열을 선언할 때 MAX개를 만듭니다. 이때 MAX는 최댓값인 50에 10을 더해서 60개씩 만들어요~!
    
    이론적으로는 (최댓값(50) + 2)개만 만들어도 충분한데, 그냥 습관이 되어 넉넉히 10개 추가해서 사용하고 있습니다 ㅎㅎ
    그러면 여러모로 고려할 예외 케이스가 줄어들어서 코드도 간결해져요.
    ------
    MAX = 50 + 10은 배열의 인덱스를 다루기 위한 여유 공간을 확보하기 위한 것입니다. 
    문제에서 주어진 최대값이 50이고, 배열의 인덱스는 0부터 시작하기 때문에 이론적으로는 51개의 공간이 필요합니다.
    그런데 이 코드에서는 ****좌표를 1부터 사용하고 있으므로, 실제로 필요한 배열의 크기는 52입니다.****
                        ㄴ ( 배열은 0부터 인덱싱이 시작되므로, 최대값이 50이면 인덱스는 0부터 50까지 총 51개가 필요합니다. 
                            즉, 0~50을 표현하는 데는 51개의 공간이 필요합니다.
                            그런데 이 코드에서는 배열의 인덱스를 1부터 사용하고 있습니다. 
                            즉, 인덱스 0은 사용하지 않고, 인덱스 1부터 50까지를 사용합니다. 
                            따라서 이를 표현하려면 실제로는 0부터 50까지의 51개 공간에 추가로 인덱스 0의 공간이 필요하므로 총 52개의 공간이 필요하게 됩니다. 
                            )

    그럼에도 불구하고 MAX = 50 + 10으로 설정한 이유는 인덱스를 벗어나는 오류를 방지하고자 여유 공간을 두기 위함입니다.
    
    코드를 작성할 때, 배열의 인덱스가 범위를 벗어나는 것은 매우 치명적인 오류를 일으킬 수 있습니다. 따라서, 여유 분의 공간을 두어 이런 오류를 방지하는 것은 좋은 습관입니다.
    배열의 최대 크기는 파이썬에서 제한되지 않으며, 사용 가능한 메모리에 따라 달라집니다. 따라서 MAX의 값은 문제의 조건과 개발자의 판단에 따라 결정됩니다.
    '''
    # 그래프 정보 입력
    for _ in range(k):
        x, y = map(int, input().split())
        graph[y + 1][x + 1] = True

    # 2. 방문하지 않은 지점부터 dfs 돌기
    result = 0
    for i in range(1, n + 1): #세로길이 = n
        for j in range(1, m + 1): #가로길이 = m
            if graph[i][j]:
                dfs(i, j)
                result += 1

    print(result)
#
# # 입력 예시
# '''
# 1
# 5 3 6
# 0 2
# 1 2
# 2 2
# 3 2
# 4 2
# 4 0
# '''

'''
- graph[m][n]에서 m은 가로길이 즉, 열의 개수를 나타내고,
                 n은 세로길이 즉, 행의 개수를 나타냅니다.
                 
그러나, 흔히 2차원 배열에서 행을 y, 열을 x로 표현하곤 합니다. 
 따라서 graph[y][x] 형태로 사용하는 것이 일반적입니다.
  따라서 dfs(i, j)에서 i는 행, j는 열을 나타내므로 dfs(y, x)로 매개변수를 받아야 합니다.

dfs 함수 내부에서는 x와 y를 이용해 상하좌우를 확인하며 재귀호출을 하게 됩니다. 
 따라서, nx = x + dx[i], ny = y + dy[i]로 새로운 위치를 계산하고, graph[ny][nx]를 통해 해당 위치의 값을 확인한 후, dfs(ny, nx)로 재귀호출을 합니다.

이때 ny와 nx는 각각 y와 x의 새로운 값이고, 이를 dfs의 매개변수로 넘겨줍니다. 
 따라서 dfs(ny, nx)는 실제로 dfs(new y, new x)를 의미합니다. 
 이런 식으로 y와 x의 값이 계속 갱신되면서 재귀호출이 이루어집니다.
'''

# "i와 j의 역할을 바꿔서 사용하는 이유가 뭔가요?"
'''
파이썬에서 2차원 리스트를 다룰 때, 일반적으로 첫 번째 인덱스를 행(row)으로, 두 번째 인덱스를 열(column)으로 사용합니다.
예를 들어, graph[i][j]에서 i는 행을, j는 열을 나타냅니다. 이는 2차원 공간에서의 좌표와 일치하는데, 

일반적으로 좌표계에서는 (x, y)와 같이 표현하며, x는 가로 방향(열)을, y는 세로 방향(행)을 나타냅니다.
따라서 dfs 함수에서는 좌표계의 관례에 따라 x, y 순서를 사용하는 것이 자연스럽습니다. 즉, dfs(x, y) 또는 dfs(column, row) 형태로 사용합니다.

하지만 for문에서는 일반적으로 행 우선으로 리스트를 순회하기 때문에, for i in range(n)과 for j in range(m) 구조를 사용합니다. 이 경우 i는 행 인덱스, j는 열 인덱스를 나타냅니다.
따라서 이 두 가지 관례 때문에 i와 j의 역할이 dfs 함수 내부와 외부에서 바뀌게 됩니다. 
함수 호출 시에는 좌표계의 관례에 따라 (x, y) 즉, (j, i) 순서로 인자를 전달하고, 함수 내부에서는 이를 다시 (y, x) 즉, (i, j) 순서로 해석하여 처리하게 됩니다.
'''

