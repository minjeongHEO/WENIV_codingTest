# 1이 될 때까지 - 그리디
# n => 1 이 될 때까지
# 1 or 2 하나를 반복 수행
#
# 두번째 연산은 n%k 일 때만 선택가능
# 1. n -= 1
# 2. n // k

n, k = map(int, input().split())
count = 0

while True:
    if n == 1:
        break

    if n % k == 0:
        n //= k
    else:
        n -= 1

    count += 1

print(count)
# =================================================================
# # 최적화 코드
# # N, K공백을 기준으로 구분하여 입력 받기
# n, k = map(int, input().split())
#
# result = 0
#
# while True:
#     # N이 K로 나누어 떨어지는 수가 될 때까지만 1씩 빼기
#     target = (n // k) * k
#     ''' 1.
#     n을 k로 나누었을 때의 몫에 k를 다시 곱해주는 코드입니다.
#     이렇게 하면 n이 k로 나누어 떨어질 수 있는 가장 가까운 수를 구할 수 있습니다.
#     '''
#     result += (n - target)
#     ''' 2.
#     n에서 target을 뺀 값을 result에 더해줍니다.
#     이는 n이 k로 나누어 떨어지지 않을 때,
#     n을 k로 나누어 떨어질 수 있을 때까지 1씩 빼는 과정을 한 번에 처리하는 것입니다.
#     '''
#     n = target
#     ''' 3.
#      n을 k로 나누어 떨어질 수 있는 수로 업데이트합니다.
#     '''
#
#
#     # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
#     if n < k:
#         break
#     # K로 나누기
#     result += 1
#     n //= k
#
# # 마지막으로 남은 수에 대하여 1씩 빼기
# result += (n - 1)
# print(result)

'''
입력 받는 수
25 5
'''

